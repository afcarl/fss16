[<img width=900 src="https://raw.githubusercontent.com/txt/fss16/master/img/fss16.png">](http://tiny.cc/fss2016)   
[Home](http://tiny.cc/fss2016) |
[At a glance...](https://github.com/txt/fss16/blob/master/doc/glance.md) |
[Syllabus](https://github.com/txt/fss16/blob/master/doc/syllabus.md) |
[Submit](http://tiny.cc/fss2016give) |
[Discuss](https://fss16.slack.com/) |
[Lecturer](http://menzies.us) |
[&copy; 2016](https://github.com/txt/fss16/blob/master/LICENSE.md) tim@menzies.us

_______



# Foundations of Software Science 

<img src="/_img/mad.jpg" align=right width=300>

Most software companies now learn their policies via
data-driven methods. Modern practitioners treat
every planned feature as an experiment, of which
only a few are expected to survive. Key performance
metrics are carefully monitored and analyzed to
judge the progress of a feature. Even simple design
decisions such as the color of a link are chosen by
the outcome of software experiments.

This subject will explore methods for designing data
collection experiments; collecting that data;
exploring that data; then presenting that data in
such a way to support business-level decision making
for software projects.

## But Why "Software Science" and not plain-old "Data Science"

Because software science is different. Consider what it means to reason about software:

1. Software Science is about software engineering which means that effective software scientists need extensive domain knowledge about software engineering.

2. While other communities might be content to use data science software tools, built by others, software scientists know how
to maintain and extend and deply rapdily changing software. Hence while  AI researchers might be the source of 
better data miners algorithms, it is software  scientists who package and wrap those algorithms
in environments that support usability, reproducibility, maintainability and scalability.

3. Extensive sets of standard for what is a valid experiment.

4. Software scientists must explain their results to software engineerings-- who are busy people. Hence, software
scientists need to be very concerned about the comprehensibility of the learned models.

4. The inherent complexity of the task of software science:
     - Constantly changing effects: new developers, new platforms, new tools, new tasks.
     - Socio-technical factors that mean we cannot reason just about software but we also have to reason over the communities of people that design, build, use, and host those tools
     - No underlying physical/chemical theory we can rely on for reasoning from first principles.  No background theory
(e.g. Blackâ€“Scholes or E=mc^2). Welcome to Simon's
[science of the artificial](http://courses.washington.edu/thesisd/documents/Kun_Herbert%20Simon_Sciences_of_the_Artificial.pdf): a constantly changing phenomena which we keep changing, every time we study it.

5.  At the same time, inherent simplicities in the data we study:

    - A fundamental simplicity to the thing we are modeling (software). Welcome to Devanbu's [naturalness of software](http://macbeth.cs.ucdavis.edu/natural.pdf):
          - <em> Programmingg languages, in theory, are complex, flexible
and powerful, but the programs that real people
actually write are mostly simple and rather repetitive,
and thus they have usefully predictable statistical properties
that can be captured in statistical language models
and leveraged for software engineering tasks.</em>


6. Finally, software engineers are engineers and hence are duty bound to follow
ethical practices in their work. Appropriate ethics for data science is still an
evolving area-- which means that software scientists have to be more alert to
  ethical issues that  other kinds of data scientists 

Point 2  means that software scientists are
sources of innovation and improvement for data
science tools.

Points 4 means we must always be modeling, always
checking old theories,
never accepting the models from other people without due diligence.  

And point 5 makes everything possible.
Naturalness is what makes it possible to
understand software using simple models (which is
[James Larus](https://www.youtube.com/watch?v=kO9OYnkeRTM)'s
point).  So, sure, sometimes, we need deep learning
etc etc for some complex text,video, audio
artifacts. But also, for most other things we can
generate simple models that people can use. And
simplicity means comprehenssibility and usability.
 
